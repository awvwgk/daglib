var tipuesearch = {"pages":[{"title":" daglib ","text":"daglib Overview DAGLIB is a modern Fortran module for creating and manipulating directed acyclic graphs (DAGs). It includes a toposort feature, and also the ability to generate files in the GraphViz \"dot\" notation. Building A Fortran Package Manager manifest file is included, so that the library and tests cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release Example A simple example is shown below: program dag_example use dag_module implicit none type ( dag ) :: d integer , dimension (:), allocatable :: order integer :: istat integer :: i integer , parameter :: n_nodes = 6 character ( len =* ), parameter :: filetype = 'pdf' ! create a dag: call d % set_vertices ( n_nodes ) call d % set_edges ( 2 ,[ 1 ]) ! 2 depends on 1 call d % set_edges ( 3 ,[ 5 , 1 ]) ! 3 depends on 5 and 1 call d % set_edges ( 4 ,[ 5 ]) ! 4 depends on 5 call d % set_edges ( 5 ,[ 2 ]) ! 5 depends on 2 call d % set_edges ( 6 ,[ 2 , 4 ]) ! 6 depends on 2 and 4 ! toposort: call d % toposort ( order , istat ) ! define some styles for the GraphViz output: do i = 1 , n_nodes if ( i == 3 . or . i == 6 ) then call d % set_vertex_info ( i , attributes = 'shape=square,fillcolor=\"SlateGray1\",style=filled' ) else call d % set_vertex_info ( i , attributes = 'shape=circle,fillcolor=\"cornsilk\",style=filled' ) end if end do ! generate the GraphViz output: call d % save_digraph ( 'test.dot' , 'RL' , 300 ) call d % destroy () call execute_command_line ( 'dot -Tpdf -o test.pdf test.dot' ) end program dag_example This program produces the toposort order: order = [1, 2, 5, 3, 4, 6] and the image file: License This library is released under a BSD-3 license . See also dag (a fork of this project) Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"dag_module.f90 – daglib","text":"Contents Modules dag_module Source Code dag_module.f90 Source Code !******************************************************************************* !> !  DAG Module. module dag_module implicit none private type :: vertex !! a vertex of a directed acyclic graph (DAG) private integer , dimension (:), allocatable :: edges !! these are the vertices that this vertex depends on integer :: ivertex = 0 !! vertex number logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph contains generic :: set_edges => set_edge_vector , add_edge procedure :: set_edge_vector procedure :: add_edge end type vertex type , public :: dag !! a directed acyclic graph (DAG) private integer :: n = 0 !! number of `vertices` type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. contains procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_edges => dag_set_edges procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: toposort => dag_toposort procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: destroy => dag_destroy end type dag contains !******************************************************************************* !******************************************************************************* !> !  Destroy the `dag`. subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy !******************************************************************************* !******************************************************************************* !> !  specify the edge indices for this vertex subroutine set_edge_vector ( me , edges ) class ( vertex ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: edges integer :: i !! counter if ( allocated ( me % edges )) then do i = 1 , size ( edges ) call me % add_edge ( edges ( i )) end do else allocate ( me % edges ( size ( edges ))) ! note: not checking for uniqueness here. me % edges = edges end if end subroutine set_edge_vector !******************************************************************************* !******************************************************************************* !> !  add an edge index for this vertex subroutine add_edge ( me , edge ) class ( vertex ), intent ( inout ) :: me integer , intent ( in ) :: edge if ( allocated ( me % edges )) then if (. not . any ( edge == me % edges )) then me % edges = [ me % edges , edge ] ! auto lhs reallocation end if else allocate ( me % edges ( 1 )) me % edges = [ edge ] end if end subroutine add_edge !******************************************************************************* !******************************************************************************* !> !  get the edges for the vertex (all the the vertices !  that this vertex depends on). pure function dag_get_edges ( me , ivertex ) result ( edges ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: edges if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges ! auto LHS allocation end if end function dag_get_edges !******************************************************************************* !******************************************************************************* !> !  get all the vertices that depend on this vertex. pure function dag_get_dependencies ( me , ivertex ) result ( dep ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies !******************************************************************************* !******************************************************************************* !> !  set the number of vertices in the dag subroutine dag_set_vertices ( me , nvertices ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: nvertices !! number of vertices integer :: i me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] end subroutine dag_set_vertices !******************************************************************************* !******************************************************************************* !> !  set info about a vertex in a dag. subroutine dag_set_vertex_info ( me , ivertex , label , attributes ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. if ( present ( label )) then me % vertices ( ivertex )% label = label else ! just use the vertex number me % vertices ( ivertex )% label = integer_to_string ( ivertex ) end if if ( present ( attributes )) then me % vertices ( ivertex )% attributes = attributes end if end subroutine dag_set_vertex_info !******************************************************************************* !******************************************************************************* !> !  set the edges for a vertex in a dag subroutine dag_set_edges ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number integer , dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges !******************************************************************************* !******************************************************************************* !> !  Main toposort routine subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer , intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer :: i , iorder if ( me % n == 0 ) return allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j ))) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG. ! !### Example !  * To convert this to a PDF using `dot`: `dot -Tpdf -o test.pdf test.dot`, !    where `test.dot` is `str` written to a file. function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) implicit none class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: i , j !! counter integer :: n_edges !! number of edges character ( len = :), allocatable :: attributes , label logical :: has_label , has_attributes character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n has_label = allocated ( me % vertices ( i )% label ) has_attributes = allocated ( me % vertices ( i )% attributes ) if ( has_label ) label = 'label=\"' // trim ( adjustl ( me % vertices ( i )% label )) // '\"' if ( has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ',' // label // ']' elseif ( has_label . and . . not . has_attributes ) then attributes = '[' // label // ']' elseif (. not . has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ']' else ! neither attributes = '' end if str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end do str = str // newline // '}' end function dag_generate_digraph !******************************************************************************* !******************************************************************************* !> !  Generate the dependency matrix for the DAG. ! !  This is an n \\times n  matrix with elements A_{ij}, !  such that A_{ij} is true if vertex i depends on vertex j. subroutine dag_generate_dependency_matrix ( me , mat ) implicit none class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer :: i !! vertex counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then mat ( i , me % vertices ( i )% edges ) = . true . end if end do end if end subroutine dag_generate_dependency_matrix !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG and write it to a file. subroutine dag_save_digraph ( me , filename , rankdir , dpi ) implicit none class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph !******************************************************************************* !******************************************************************************* !> !  Integer to allocatable string. pure function integer_to_string ( i ) result ( s ) implicit none integer , intent ( in ) :: i character ( len = :), allocatable :: s integer :: istat allocate ( character ( len = 64 ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string !******************************************************************************* !******************************************************************************* end module dag_module !*******************************************************************************","tags":"","loc":"sourcefile/dag_module.f90.html"},{"title":"vertex – daglib ","text":"type, public :: vertex a vertex of a directed acyclic graph (DAG) Inherited by type~~vertex~~InheritedByGraph type~vertex vertex type~dag dag type~dag->type~vertex vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables edges ivertex checking marked label attributes Type-Bound Procedures set_edges set_edge_vector add_edge Source Code vertex Components Type Visibility Attributes Name Initial integer, private, dimension(:), allocatable :: edges these are the vertices that this vertex depends on integer, private :: ivertex = 0 vertex number logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph Type-Bound Procedures generic, public :: set_edges => set_edge_vector , add_edge private subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges private subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge procedure, public :: set_edge_vector private subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges procedure, public :: add_edge private subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge Source Code type :: vertex !! a vertex of a directed acyclic graph (DAG) private integer , dimension (:), allocatable :: edges !! these are the vertices that this vertex depends on integer :: ivertex = 0 !! vertex number logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph contains generic :: set_edges => set_edge_vector , add_edge procedure :: set_edge_vector procedure :: add_edge end type vertex","tags":"","loc":"type/vertex.html"},{"title":"dag – daglib ","text":"type, public :: dag a directed acyclic graph (DAG) Inherits type~~dag~~InheritsGraph type~dag dag type~vertex vertex type~dag->type~vertex vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables n vertices Type-Bound Procedures set_vertices set_edges set_vertex_info toposort generate_digraph generate_dependency_matrix save_digraph get_edges get_dependencies destroy Source Code dag Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of vertices type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. Type-Bound Procedures procedure, public :: set_vertices => dag_set_vertices private subroutine dag_set_vertices (me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices procedure, public :: set_edges => dag_set_edges private subroutine dag_set_edges (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges procedure, public :: set_vertex_info => dag_set_vertex_info private subroutine dag_set_vertex_info (me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. procedure, public :: toposort => dag_toposort private subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: 0 if no errors -1 if circular dependency\n (in this case, order will not be allocated) procedure, public :: generate_digraph => dag_generate_digraph private function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:),\n  allocatable procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix private subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix procedure, public :: save_digraph => dag_save_digraph private subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) procedure, public :: get_edges => dag_get_edges private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer,\n  dimension(:), allocatable procedure, public :: get_dependencies => dag_get_dependencies private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer,\n  dimension(:), allocatable the set of all vertices\nthan depend on ivertex procedure, public :: destroy => dag_destroy private subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Source Code type , public :: dag !! a directed acyclic graph (DAG) private integer :: n = 0 !! number of `vertices` type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. contains procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_edges => dag_set_edges procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: toposort => dag_toposort procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: destroy => dag_destroy end type dag","tags":"","loc":"type/dag.html"},{"title":"dag_get_edges – daglib","text":"private pure function dag_get_edges(me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer,\n  dimension(:),allocatable Contents Source Code dag_get_edges Source Code pure function dag_get_edges ( me , ivertex ) result ( edges ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: edges if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges ! auto LHS allocation end if end function dag_get_edges","tags":"","loc":"proc/dag_get_edges.html"},{"title":"dag_get_dependencies – daglib","text":"private pure function dag_get_dependencies(me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer,\n  dimension(:),allocatable the set of all vertices\nthan depend on ivertex Contents Source Code dag_get_dependencies Source Code pure function dag_get_dependencies ( me , ivertex ) result ( dep ) implicit none class ( dag ), intent ( in ) :: me integer , intent ( in ) :: ivertex integer , dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies","tags":"","loc":"proc/dag_get_dependencies.html"},{"title":"dag_generate_digraph – daglib","text":"private function dag_generate_digraph(me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Example To convert this to a PDF using dot : dot -Tpdf -o test.pdf test.dot ,\n    where test.dot is str written to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:),\n  allocatable Calls proc~~dag_generate_digraph~~CallsGraph proc~dag_generate_digraph dag_generate_digraph proc~integer_to_string integer_to_string proc~dag_generate_digraph->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dag_generate_digraph Source Code function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) implicit none class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: i , j !! counter integer :: n_edges !! number of edges character ( len = :), allocatable :: attributes , label logical :: has_label , has_attributes character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n has_label = allocated ( me % vertices ( i )% label ) has_attributes = allocated ( me % vertices ( i )% attributes ) if ( has_label ) label = 'label=\"' // trim ( adjustl ( me % vertices ( i )% label )) // '\"' if ( has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ',' // label // ']' elseif ( has_label . and . . not . has_attributes ) then attributes = '[' // label // ']' elseif (. not . has_label . and . has_attributes ) then attributes = '[' // trim ( adjustl ( me % vertices ( i )% attributes )) // ']' else ! neither attributes = '' end if str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end do str = str // newline // '}' end function dag_generate_digraph","tags":"","loc":"proc/dag_generate_digraph.html"},{"title":"integer_to_string – daglib","text":"private pure function integer_to_string(i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:),\n  allocatable Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~dag_set_vertex_info dag_set_vertex_info proc~dag_set_vertex_info->proc~integer_to_string proc~dag_generate_digraph dag_generate_digraph proc~dag_generate_digraph->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code integer_to_string Source Code pure function integer_to_string ( i ) result ( s ) implicit none integer , intent ( in ) :: i character ( len = :), allocatable :: s integer :: istat allocate ( character ( len = 64 ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string","tags":"","loc":"proc/integer_to_string.html"},{"title":"dag_destroy – daglib","text":"private subroutine dag_destroy(me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Contents Source Code dag_destroy Source Code subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy","tags":"","loc":"proc/dag_destroy.html"},{"title":"set_edge_vector – daglib","text":"private subroutine set_edge_vector(me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges Contents Source Code set_edge_vector Source Code subroutine set_edge_vector ( me , edges ) class ( vertex ), intent ( inout ) :: me integer , dimension (:), intent ( in ) :: edges integer :: i !! counter if ( allocated ( me % edges )) then do i = 1 , size ( edges ) call me % add_edge ( edges ( i )) end do else allocate ( me % edges ( size ( edges ))) ! note: not checking for uniqueness here. me % edges = edges end if end subroutine set_edge_vector","tags":"","loc":"proc/set_edge_vector.html"},{"title":"add_edge – daglib","text":"private subroutine add_edge(me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge Contents Source Code add_edge Source Code subroutine add_edge ( me , edge ) class ( vertex ), intent ( inout ) :: me integer , intent ( in ) :: edge if ( allocated ( me % edges )) then if (. not . any ( edge == me % edges )) then me % edges = [ me % edges , edge ] ! auto lhs reallocation end if else allocate ( me % edges ( 1 )) me % edges = [ edge ] end if end subroutine add_edge","tags":"","loc":"proc/add_edge.html"},{"title":"dag_set_vertices – daglib","text":"private subroutine dag_set_vertices(me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices Contents Source Code dag_set_vertices Source Code subroutine dag_set_vertices ( me , nvertices ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: nvertices !! number of vertices integer :: i me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] end subroutine dag_set_vertices","tags":"","loc":"proc/dag_set_vertices.html"},{"title":"dag_set_vertex_info – daglib","text":"private subroutine dag_set_vertex_info(me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. Calls proc~~dag_set_vertex_info~~CallsGraph proc~dag_set_vertex_info dag_set_vertex_info proc~integer_to_string integer_to_string proc~dag_set_vertex_info->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dag_set_vertex_info Source Code subroutine dag_set_vertex_info ( me , ivertex , label , attributes ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. if ( present ( label )) then me % vertices ( ivertex )% label = label else ! just use the vertex number me % vertices ( ivertex )% label = integer_to_string ( ivertex ) end if if ( present ( attributes )) then me % vertices ( ivertex )% attributes = attributes end if end subroutine dag_set_vertex_info","tags":"","loc":"proc/dag_set_vertex_info.html"},{"title":"dag_set_edges – daglib","text":"private subroutine dag_set_edges(me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges Contents Source Code dag_set_edges Source Code subroutine dag_set_edges ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer , intent ( in ) :: ivertex !! vertex number integer , dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges","tags":"","loc":"proc/dag_set_edges.html"},{"title":"dag_toposort – daglib","text":"private subroutine dag_toposort(me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: 0 if no errors -1 if circular dependency\n (in this case, order will not be allocated) Contents Source Code dag_toposort Source Code subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer , intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer :: i , iorder if ( me % n == 0 ) return allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j ))) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort","tags":"","loc":"proc/dag_toposort.html"},{"title":"dag_generate_dependency_matrix – daglib","text":"private subroutine dag_generate_dependency_matrix(me, mat) Generate the dependency matrix for the DAG. This is an matrix with elements ,\nsuch that is true if vertex depends on vertex . Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix Contents Source Code dag_generate_dependency_matrix Source Code subroutine dag_generate_dependency_matrix ( me , mat ) implicit none class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer :: i !! vertex counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then mat ( i , me % vertices ( i )% edges ) = . true . end if end do end if end subroutine dag_generate_dependency_matrix","tags":"","loc":"proc/dag_generate_dependency_matrix.html"},{"title":"dag_save_digraph – daglib","text":"private subroutine dag_save_digraph(me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Contents Source Code dag_save_digraph Source Code subroutine dag_save_digraph ( me , filename , rankdir , dpi ) implicit none class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer , intent ( in ), optional :: dpi !! resolution (e.g. 300) integer :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph","tags":"","loc":"proc/dag_save_digraph.html"},{"title":"dag_module – daglib","text":"DAG Module. Contents Derived Types vertex dag Functions dag_get_edges dag_get_dependencies dag_generate_digraph integer_to_string Subroutines dag_destroy set_edge_vector add_edge dag_set_vertices dag_set_vertex_info dag_set_edges dag_toposort dag_generate_dependency_matrix dag_save_digraph Derived Types type, public :: vertex a vertex of a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial integer, private, dimension(:), allocatable :: edges these are the vertices that this vertex depends on integer, private :: ivertex = 0 vertex number logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph Type-Bound Procedures generic, public :: set_edges => set_edge_vector, add_edge procedure, public :: set_edge_vector procedure, public :: add_edge type, public :: dag a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of vertices type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. Type-Bound Procedures procedure, public :: set_vertices => dag_set_vertices procedure, public :: set_edges => dag_set_edges procedure, public :: set_vertex_info => dag_set_vertex_info procedure, public :: toposort => dag_toposort procedure, public :: generate_digraph => dag_generate_digraph procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure, public :: save_digraph => dag_save_digraph procedure, public :: get_edges => dag_get_edges procedure, public :: get_dependencies => dag_get_dependencies procedure, public :: destroy => dag_destroy Functions private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all the the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer,\n  dimension(:), allocatable private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer, intent(in) :: ivertex Return Value integer,\n  dimension(:), allocatable the set of all vertices\nthan depend on ivertex private function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:),\n  allocatable private pure function integer_to_string (i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:),\n  allocatable Subroutines private subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me private subroutine set_edge_vector (me, edges) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in), dimension(:) :: edges private subroutine add_edge (me, edge) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer, intent(in) :: edge private subroutine dag_set_vertices (me, nvertices) set the number of vertices in the dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: nvertices number of vertices private subroutine dag_set_vertex_info (me, ivertex, label, attributes) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. private subroutine dag_set_edges (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(in) :: ivertex vertex number integer, intent(in), dimension(:) :: edges private subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: order the toposort order integer, intent(out) :: istat Status flag: 0 if no errors -1 if circular dependency\n (in this case, order will not be allocated) private subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix private subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer, intent(in), optional :: dpi resolution (e.g. 300)","tags":"","loc":"module/dag_module.html"}]}